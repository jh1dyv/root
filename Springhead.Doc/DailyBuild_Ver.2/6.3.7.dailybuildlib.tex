% 6.3.7.dailybuildlib.tex
%	Last update: 2018/07/12 F.Kanehori
%\newpage
\subsubsection{dailybuild\_lib.pm}
\label{subsubsec:dailybuildlib}

\medskip
\noindent
Daily Buildの結果解析で共通に使用する関数のライブラリ

\bigskip
\begin{Methods}{サブルーチンの説明}
\Method{read_log((\BS \%modules, \BS @modules, \BS @lines)\\
	\hspace{60pt}= read_log(\$logfile, \$script [, \$patt_id])}{%
    \begin{Params}
	\Param{\$logfile}{ログファイル名}
	\Param{\$script}{呼び出し元スクリプト名(エラー表示用)}
	\Param{\$patt_id}{モジュール開始パターンID(下表参照)}
    \end{Params}
    \vspace{.7\baselineskip}
    \begin{narrow}[10pt]
	\begin{tabular}{cll}\hline
	     id & \MC{1}{c}{pattern} & \MC{1}{c}{用 途}\\\hline
	     0  & \DQuote{*** \it{proj}: \it{solution} ***}
		& \Path{Build.log}及び\Path{Run.log}用\\
	     1  & \DQuote{\it{num}\tt{>} *** \it{proj}: \it{solution} ***}
		& \Path{StubBuild.log}用\\
	     2  & \DQuote{[ \it{alnum} ]}
	    	& \tt{filter.pl}用\\\hline
	\end{tabular}
    \end{narrow}
    \vspace{.7\baselineskip}
    \noindent 戻り値
    \begin{narrow}[\WID]
	\begin{Table}[r][4em]{ll}
	  \Item{\%modules}{モジュール名とスレッド情報を関連付けた連想配列。
			キーはモジュール名、値は\tt{\%threads}の参照。
			ここで\tt{\%threads}はスレッド情報を格納する連想配列で、
			キーはスレッド番号、値はそのスレッドに属するログ行。}
	  \Item{@modules}{モジュール名を出現順に格納した配列}
	  \Item{@lines}{ログの各行を出現順に格納した配列}
	\end{Table}
    \end{narrow}
    \begin{General}
	指定されたログファイルを読み込み、モジュール毎にスレッド順に整理する。\\
	モジュールの開始パターンは3種類あり、どれを使うかは引数で指定する
	(引数の説明参照)。\\
	スレッド関連より前に出力されたログ行は、
	スレッド番号$-1$のスレッドに属するものとして扱う。
	また、スレッド関連より後に出力されたログ行は、
	スレッド番号$999$のスレッドに属するものとして扱う。
    \end{General}
}
\Method{\$number = outside_threads_before()\\
	\$number = outsize_threads_after()}{%
    \begin{General}
	それぞれ、スレッド情報より前の部分に対する仮想スレッド番号($-1$)
	及びスレッド情報より後の部分に対する仮想スレッド番号($999$)を返す。
    \end{General}
}
\Method{(\BS @modules1, \BS @modules2)\\
	= associate_modules(\BS @modules1, \BS@modules2, \$script)}{%
    \begin{Params}
	\Param{\BS @modules1}{比較の元(``左側'')となる入力行の配列}
	\Param{\BS @modules2}{比較する(``右側'')側の入力行の配列}
    \end{Params}
    \begin{General}
	引数で指定された2つのモジュール配列(\tt{@modules1}, \tt{@modules2}とする)の
	対応する要素が同じモジュールとなるように各配列の要素を調整する。
	そのために、
	\tt{@modules1}にしかないモジュールに対しては
	\tt{@modules2}に削除モジュールマーク(`\tt{_DEL_}')を挿入することで、
	\tt{@modules2}にしかないモジュールに対しては
	\tt{@modules1}に挿入モジュールマーク(`\tt{_INS_}')を挿入することで対応をとる。
	挿入モジュールマーク及び削除モジュールマークは
	\tt{mod_ins()}及び\tt{mod_del()}で取得する。下図参照。\\
	\begin{narrow}[\WID]
	\def\CLINE{\cline{1-1}\cline{3-3}\cline{5-5}\cline{7-7}}
	\def\RA{ \hspace{10pt}$\Rightarrow$\hspace{10pt} }
	\begin{tabular}{|c|c|c|c|c|c|c|}
		\MC{3}{c}{input} & \MC{1}{c}{} & \MC{3}{c}{output}\\\CLINE
		1 && 1 & \RA & 1 && 1\\\CLINE
		2 && X & \RA & \tt{_ins_} && X\\\CLINE
		3 && 2 & \RA & 2 && 2\\\CLINE
		4 && 3 & \RA & 3 && 3\\\CLINE
		5 && 5 & \RA & 4 && \tt{_del_}\\\CLINE
		\MC{1}{c}{modules1} & \MC{1}{c}{} & \MC{1}{c}{modules2} & \MC{1}{c|}{}
			& 5 && 5\\\cline{5-5}\cline{7-7}
		\MC{4}{c}{} & \MC{1}{c}{\tt{modules1}} &
		\MC{1}{c}{} & \MC{1}{c}{\tt{modules2}}
	\end{tabular}
	\end{narrow}
    \end{General}
}
\Method{mod_ins()\\
	mod_del()}{%
    \begin{General}
	それぞれ、挿入モジュールマーク(\tt{`_INS_'})、
	削除モジュールマーク(\tt{`_DEL_'})を返す。
    \end{General}
}
\Method{\BS @buff = gather_lines(\BS \%modules, \$module)}{%
    \begin{Params}
	\Param{\%modules}{モジュール名と入力行を対応付けた連想配列}
	\Param{\$module}{抽出するモジュールの名前}
    \end{Params}
    \noindent 戻り値
    \begin{narrow}[\WID]
	\begin{Table}[r][4em]{ll}
	  \Item{@buff}{\tt{\%modules}から該当するモジュールの入力行を抽出した配列}
	\end{Table}
    \end{narrow}
    \begin{General}
	モジュール名とスレッド情報を関連付けた連想配列から、
	指定されたスレッドのログのみを抽出する。
	\tt{rad_log()}で返された\tt{\%modules}を処理の対象とする。
    \end{General}
}
\end{Methods}

% end: 6.3.7.dailybuildlib.tex
