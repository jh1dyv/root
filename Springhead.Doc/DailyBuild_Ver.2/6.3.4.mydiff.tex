% 6.3.4.mydiff.tex
%	Last update: 2018/06/25 F.Kanehori
%\newpage
\subsubsection{mydiff.pl}
\label{subsubsec:mydiff}

\medskip
\noindent
Visual Studio (devenv) が出力したログを比較して、共通する行を取り除く。
処理はモジュール単位に行なう。

\bigskip
\noindent
起動方法
\Cmnd{4pt}{perl order.pl [options] file1 file2}{-8pt}

\begin{CmndOpts}[6em]
    \CmndOpt{-c}{context diff出力 (未実装)}
    \CmndOpt{-o outfile}{出力ファイル名 (stdout\NOTE)}
    \CmndOpt{-p patt_id}{モジュール識別パターン番号}
    \CmndOpt{-D n}{デバッグレベル設定}
\end{CmndOpts}

\begin{CmndArgs}[6em]
    \CmndArg{file1}{入力ファイル名1}
    \CmndArg{file2}{入力ファイル名2}
\end{CmndArgs}

\begin{Process}
\begin{enumerate}
  \item	指定された2つのファイルそれぞれについて、
	\tt{dailybuild\_lib.pm}のライブラリ関数\tt{read\_log()}を用いて
	入力ファイルの読み込み処理を行なう。
	返されるのは(\tt{\%modules, @modules, @lines})の3つ組である。\\
	\vspace{-.7\baselineskip}
	\begin{narrow}[10pt]\small{\begin{tabular}{ll}
	    \tt{\%modules}
		& モジュール名をキーとした連想配列(要素は\tt{\%threads})\\
	    \tt{\%threads}
		& スレッド番号をキーとした連想配列(要素は入力データ行の配列)\\
	    \tt{@modules}
		& モジュール名の配列(出現順)
	\end{tabular}}\end{narrow}
	\medskip

  \item	\tt{dailybuild\_lib.pm}のライブラリ関数\tt{associate\_modules()}を用いて
	2つのファイルのモジュール名の対応をとる。
	すなわち、両方のファイルでモジュールの出現順序が同じとなるように
	データ行を並べ替える。
	このとき、片方のファイルにしかないモジュールについては、
	特別なモジュールマークを挿入することで識別する
	(\REF{subsubsec}{dailybuildlib})。\\
	返されるのはデータ行配列の2つ組(\tt{@modules1, @modules2})である。

  \item	すべてのモジュールについて、
	\begin{enumerate}
	  \item	どちらか一方のファイルにしかないモジュールの場合は、
		行頭に``\textless''か``\textgreater''を付けて出力ファイルに書き出す
		(\Ref{mydiff:gatherlines})。
	  \item	両方にファイルにあるモジュールの場合は、
		差分情報を出力ファイルに書き出す(\Ref{mydiff:diff})
	\end{enumerate}
\end{enumerate}
\end{Process}

\begin{Methods}{サブルーチン}
\def\BS{\textbackslash}
\def\BuffA{\tt{@buff1}}
\def\BuffB{\tt{@buff2}}
\def\LineA{\tt{line1}}
\def\LineB{\tt{line2}}
\def\ABRA#1{{\footnotesize <\rm{#1}>}}

\Method{\ABRA{戻り値} = diff(\$fh, \ABRA{基準データ1}, \ABRA{比較データ2})}{%
    \label{mydiff:diff}
    %\vspace{.5\baselineskip}
    \begin{Params}
	\Param{\$fh}{出力ファイル}
	\Param{\ABRA{比較データ1}}{比較の基準となるデータ。次の三つ組。
		\begin{narrow}[20pt]\begin{tabular}{ll}
		    \tt{\BS\%modules} & モジュール名と入力行を対応付けた連想配列\\
		    \tt{\$module}     & 処理対象モジュール名\\
		    \tt{\$base}       & 当該モジュール先頭行の行番号
		\end{tabular}\end{narrow}
	}
	\Param{\ABRA{比較データ2}}{比較するデータ。上と同じ三つ組。}
    \end{Params}
    \noindent 戻り値
    \begin{narrow}[\WID]
	\tt{\%module1}と\tt{\%module2}について
	処理が済んだ行数のペア
    \end{narrow}
    \begin{General}
	モジュール1とモジュール2とを比較して差分情報を作成する。
	比較の対象となるデータ行は、
	\tt{gather_lines()}を用いて\BuffA と\BuffB に取り出す
	(\tt{\%modules\it{N}[\$module\it{N}]}の全体をスレッド順にソートしたもの)。\\
	\BuffA と\BuffB の各行を先頭から順に比較していって次の処理を行なう
	(\tt{\$count\it{N}}は\tt{@buff\it{N}}内で処理が済んだ行数をカウントするのに
	用いる変数である)。
	\begin{itemize}
	  \item	\BuffB だけに行が残っているならば、それらは末尾に挿入された行である。
		\BuffB に残った行を出力する(\ref{mydiff:eatup} eat_up参照)。
	  \item	\BuffA だけに行が残っているならば、それらは末尾から削除された行である。
		\BuffA に残った行を破棄する(\ref{mydiff:eatup} eat_up参照)。
	  \item	\BuffA の先頭行を\LineA 、\BuffB の先頭行を\LineB とする。
	  	\LineA と\LineB とが同じならば、
		未出力行をフラッシュする(\Ref{mydiff:flush}{flush})。
		なければカウントを進めるだけ。
	  \item	\LineA と\LineB とが異なっている場合で、
	  	\LineA が\BuffB になく、かつ\LineB が\BuffA にあるならば、
		それは削除された行である。
	  	\BuffA のうち\LineB の前までの部分を削除バッファ(\tt{@del_buff})に
		追加する。
	  \item	同じく\LineA と\LineB とが異なっている場合で、
	  	逆に\LineA が\BuffB にあり。かつ\LineB が\BuffA にないならば、
		それは挿入された行である。
	  	\BuffB のうち\LineA の前までの部分を挿入バッファ(\tt{@ins_buff})に
		追加する。
	  \item	それ以外で\LineA と\LineB とが異なっている場合は、
		\LineA を削除バッファ(\tt{@del_buff})に、
		\LineB を挿入バッファ(\tt{@ins_buff})に追加する。
	\end{itemize}
	最後に未出力行をフラッシュする。
    \end{General}
}
\Method{eat_up}{%
	yyy
}
\end{Methods}

% end: 6.3.4.mydiff.tex
